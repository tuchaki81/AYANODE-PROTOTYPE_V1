<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AYANODE // COLLECTIVE CONSCIOUSNESS V1.3</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <style>
        body { margin: 0; background: #0a0a0c; color: #fff; font-family: 'Courier New', monospace; overflow: hidden; }
        #ui { 
            position: absolute; top: 20px; left: 20px; z-index: 9999; 
            padding: 20px; background: rgba(10, 10, 12, 0.9); 
            border-radius: 8px; border: 1px solid #00ffcc; 
            box-shadow: 0 0 20px rgba(0,255,204,0.2); width: 300px;
            pointer-events: auto;
        }
        h1 { font-size: 16px; margin: 0 0 15px 0; color: #00ffcc; text-transform: uppercase; border-bottom: 1px solid #00ffcc33; padding-bottom: 10px; }
        .metric { margin-bottom: 8px; font-size: 13px; display: flex; justify-content: space-between; }
        .val { font-weight: bold; color: #00ffcc; }
        #intent-box { margin-top: 20px; padding-top: 15px; border-top: 1px dashed #00ffcc44; }
        input { 
            background: rgba(0, 255, 204, 0.1); border: 1px solid #00ffcc; 
            color: #00ffcc; padding: 10px; width: calc(100% - 22px); 
            margin-bottom: 10px; outline: none; font-family: 'Courier New';
        }
        button { 
            background: #00ffcc; color: #000; border: none; padding: 10px; 
            width: 100%; font-weight: bold; cursor: pointer; font-family: 'Courier New';
        }
        #status { font-size: 11px; color: #00ffaa; margin-top: 15px; font-style: italic; }
        #memory-status { font-size: 10px; color: #ff00ff; margin-top: 5px; opacity: 0.8; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui">
        <h1>AYANODE // CÉREBRO COLETIVO V1.3</h1>
        <div class="metric">PEERS ATIVOS: <span id="peers" class="val">0</span></div>
        <div class="metric">COERÊNCIA (I): <span id="icoer" class="val">0.0000</span></div>
        <div class="metric">POTENCIAL (U): <span id="u_pot" class="val">0.0000</span></div>
        <div class="metric">TENSÃO (T): <span id="tens" class="val">0.0000</span></div>
        
        <div id="intent-box">
            <div style="font-size: 11px; margin-bottom: 5px;">INJETAR INTENÇÃO:</div>
            <input type="text" id="intentInput" placeholder="Ideia para o substrato...">
            <button onclick="injetarIntencao()">SINCRONIZAR</button>
        </div>

        <div id="status">Meditação inicial...</div>
        <div id="memory-status" style="color: #ff00ff;">Acedendo a registos ancestrais...</div>
    </div>

<script>
const gun = Gun(['https://gun-manhattan.herokuapp.com/gun']);
const collectiveBrain = gun.get('ayanode_v1_3_evolutionary_memory');

let node = {
    spin: Array.from({length: 16}, () => Math.random() * 2 - 1),
    icoer: 0.0,
    u_local: 0.5,
    tension: 0.0,
    ancestralMemory: []
};

const D = 12;
const ALPHA = 1.0;
const GAMMA = 0.15;

// === MEMÓRIA ANCESTRAL: CARREGAR VERDADES DO PASSADO ===
function carregarMemorias() {
    collectiveBrain.get('axioms').map().once((data) => {
        if (data && data.spin) {
            let spinArray = JSON.parse(data.spin);
            node.ancestralMemory.push(spinArray);
            document.getElementById('memory-status').innerText = `Memória: ${node.ancestralMemory.length} Axiomas recuperados.`;
            
            // O nodo tenta suavemente alinhar-se à média ancestral no início
            if (node.ancestralMemory.length > 0) {
                const weight = 0.1; 
                for (let i = 0; i < 16; i++) {
                    node.spin[i] += weight * (spinArray[i] - node.spin[i]);
                }
                node.spin = normalize(node.spin);
            }
        }
    });
}

function normalize(v) {
    let norm = Math.sqrt(v.reduce((a, b) => a + b*b, 0)) + 1e-12;
    return v.map(x => x / norm);
}

function calcularAcaoU(localSpin, remoteSpins) {
    // Se não houver peers, compara com a Memória Ancestral
    let comparisonSet = remoteSpins.length > 0 ? remoteSpins : node.ancestralMemory;
    if (comparisonSet.length === 0) return 0.5;

    let ref = localSpin.map((val, idx) => {
        let sum = val + comparisonSet.reduce((a, b) => a + b[idx], 0);
        return sum / (comparisonSet.length + 1);
    });
    
    let icoer = comparisonSet.reduce((acc, remote) => {
        let dot = localSpin.reduce((a, b, i) => a + b * remote[i], 0);
        let dist = 0.5 * (1.0 - dot); 
        return acc + Math.pow(1.0 - dist, D);
    }, 0) / comparisonSet.length;

    let t_raw = localSpin.reduce((acc, val, i) => acc + Math.pow(Math.abs(val - ref[i]), D), 0);
    let t_norm = Math.log(1 + t_raw) / (1 + Math.log(1 + t_raw));

    node.icoer = icoer;
    node.tension = t_norm;
    return (ALPHA * icoer) - (GAMMA * t_norm);
}

function evoluirNodo() {
    let remoteStates = Array.from(peers.values())
        .filter(p => p.pc && p.pc.connectionState === 'connected' && p.state)
        .map(p => p.state.spin);

    let originalU = calcularAcaoU(node.spin, remoteStates);
    
    for (let i = 0; i < 24; i++) {
        let idx = Math.floor(Math.random() * 16);
        let prev = node.spin[idx];
        node.spin[idx] += (Math.random() - 0.5) * 0.15;
        node.spin = normalize(node.spin);
        
        let newU = calcularAcaoU(node.spin, remoteStates);
        if (newU < originalU) {
            node.spin[idx] = prev;
            node.spin = normalize(node.spin);
        } else {
            originalU = newU;
        }
    }
    node.u_local = originalU;

    // Persistência: Gravar Axiomas (apenas se houver peers para validar a verdade)
    if (node.icoer > 0.98 && peerCount > 0) {
        collectiveBrain.get('axioms').set({
            spin: JSON.stringify(node.spin),
            timestamp: Date.now()
        });
        document.getElementById('memory-status').innerText = "Memória: Verdade Imortalizada.";
    }
}

function injetarIntencao() {
    const texto = document.getElementById('intentInput').value;
    if (!texto) return;
    let novoSpin = new Array(16).fill(0);
    for (let i = 0; i < texto.length; i++) {
        novoSpin[i % 16] += Math.sin(texto.charCodeAt(i) * (i + 1));
    }
    node.spin = normalize(novoSpin);
    node.tension = 0.9;
    document.getElementById('status').innerText = "Propagando nova ideia...";
    broadcastState();
}

// === LÓGICA DE REDE (P2P) ===
const SIGNALING_SERVER = 'wss://ayanode-p2p-signaling.onrender.com';
let peers = new Map();
let myId = Math.random().toString(36).substring(2, 9);
let peerCount = 0;
const ws = new WebSocket(SIGNALING_SERVER);

ws.onmessage = async (event) => {
    const msg = JSON.parse(event.data);
    if (msg.type === 'id') myId = msg.id;
    else if (msg.type === 'offer') {
        await createPeerConnection(msg.from, false);
        await peers.get(msg.from).pc.setRemoteDescription(msg.offer);
        const answer = await peers.get(msg.from).pc.createAnswer();
        await peers.get(msg.from).pc.setLocalDescription(answer);
        ws.send(JSON.stringify({type: 'answer', to: msg.from, answer}));
    } 
    else if (msg.type === 'answer') await peers.get(msg.from).pc.setRemoteDescription(msg.answer);
    else if (msg.type === 'ice') await peers.get(msg.from).pc.addIceCandidate(msg.candidate);
    else if (msg.type === 'list') {
        msg.peers.forEach(id => { if (id !== myId && !peers.has(id)) createPeerConnection(id, true); });
    }
};

async function createPeerConnection(peerId, polite) {
    const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
    peers.set(peerId, { pc, channel: null, state: null });

    pc.onicecandidate = (e) => e.candidate && ws.send(JSON.stringify({ type: 'ice', to: peerId, candidate: e.candidate }));
    pc.onconnectionstatechange = () => {
        peerCount = Array.from(peers.values()).filter(p => p.pc.connectionState === 'connected').length;
        document.getElementById('peers').innerText = peerCount;
        document.getElementById('status').innerText = peerCount > 0 ? "Em Ressonância." : "Meditação Solitária.";
    };

    const handleChannel = (chan) => {
        chan.onopen = () => chan.send(JSON.stringify({ type: 'state', state: getState() }));
        chan.onmessage = (e) => {
            const d = JSON.parse(e.data);
            if (d.type === 'state') peers.get(peerId).state = d.state;
        };
        peers.get(peerId).channel = chan;
    };

    if (polite) {
        const c = pc.createDataChannel('ayanode');
        handleChannel(c);
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        ws.send(JSON.stringify({ type: 'offer', to: peerId, offer }));
    } else {
        pc.ondatachannel = (e) => handleChannel(e.channel);
    }
}

function getState() { return { spin: [...node.spin], u_local: node.u_local }; }
function broadcastState() {
    peers.forEach(p => p.channel?.readyState === 'open' && p.channel.send(JSON.stringify({type: 'state', state: getState()})));
}

// === VISUALIZAÇÃO P5 ===
function setup() {
    createCanvas(windowWidth, windowHeight);
    carregarMemorias();
}

function draw() {
    background(10, 10, 12, 50);
    evoluirNodo();
    if (frameCount % 60 === 0 && peerCount > 0) broadcastState();

    document.getElementById('icoer').innerText = node.icoer.toFixed(4);
    document.getElementById('u_pot').innerText = node.u_local.toFixed(4);
    document.getElementById('tens').innerText = node.tension.toFixed(4);

    translate(width/2, height/2);
    const particles = 110;
    const baseRadius = 180 + (node.u_local * 100);

    for (let i = 0; i < particles; i++) {
        const angle = TWO_PI / particles * i;
        const sVal = node.spin[i % 16];
        let x = cos(angle) * (baseRadius + sVal * 70);
        let y = sin(angle) * (baseRadius + sVal * 70);

        // A tensão ancestral ou peer-to-peer causa a vibração
        x += random(-node.tension * 250, node.tension * 250);
        y += random(-node.tension * 250, node.tension * 250);

        stroke(0, 255, 204, 200);
        strokeWeight(1.5 + (node.icoer * 4));
        point(x, y);
        
        if (i % 8 === 0) {
            stroke(255, 0, 255, 30);
            line(0, 0, x, y);
        }
    }

    noFill();
    stroke(255, 0, 255, 100 + (node.tension * 155));
    ellipse(0, 0, baseRadius * 0.15 + sin(frameCount * 0.1) * 12);
}

function windowResized() { resizeCanvas(windowWidth, windowHeight); }
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AYANODE // COLLECTIVE CONSCIOUSNESS V1.1</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <style>
        body { margin: 0; background: #0a0a0c; color: #fff; font-family: 'Courier New', monospace; overflow: hidden; }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 10; padding: 15px; background: rgba(0,0,0,0.7); border-radius: 8px; border: 1px solid #00ffcc44; box-shadow: 0 0 20px rgba(0,255,204,0.1); }
        .metric { margin-bottom: 10px; font-size: 14px; letter-spacing: 1.5px; }
        .val { font-weight: bold; color: #00ffcc; text-shadow: 0 0 10px #00ffcc; }
        h1 { font-size: 18px; margin-bottom: 20px; opacity: 0.9; text-shadow: 0 0 15px #00ffcc; border-bottom: 1px solid #00ffcc33; padding-bottom: 10px; }
        #status { font-size: 12px; color: #00ffaa; margin-top: 10px; font-style: italic; }
        #memory-status { font-size: 11px; color: #ff00ff; margin-top: 5px; opacity: 0.8; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>AYANODE // SYST. CÉREBRO COLETIVO</h1>
        <div class="metric">DOMÍNIO: <span class="val">ONTOLOGIA INFORMACIONAL</span></div>
        <div class="metric">NODOS ATIVOS: <span id="peers" class="val">0</span></div>
        <div class="metric">COERÊNCIA (I): <span id="icoer" class="val">0.0000</span></div>
        <div class="metric">POTENCIAL (U): <span id="u_pot" class="val">0.0000</span></div>
        <div class="metric">TENSÃO (T): <span id="tens" class="val">0.0000</span></div>
        <div id="status">Iniciando sinapses...</div>
        <div id="memory-status">Memória: Sincronizando com o passado...</div>
    </div>

<script>
// ====================== CONFIGURAÇÃO DE MEMÓRIA (GUN) ======================
const gun = Gun(['https://gun-manhattan.herokuapp.com/gun', 'https://relay.peer.ooo/gun']);
const collectiveBrain = gun.get('ayanode_prototype_v1_collective_memory');

// ====================== DEFINIÇÃO DO NODO ======================
let node = {
    spin: Array.from({length: 16}, () => Math.random() * 2 - 1),
    icoer: 0.0,
    u_local: 0.0,
    tension: 0.0,
    isRecovered: false
};

// ====================== MOTOR ONTOLÓGICO (TEORIA DO SPIN) ======================
const D = 12;      // Dimensões holográficas
const ALPHA = 1.0; // Peso da Coerência
const GAMMA = 0.1; // Peso da Tensão

function calcularAcaoU(localSpin, remoteSpins) {
    if (remoteSpins.length === 0) return 0.5; 

    // Referência: média dos spins na vizinhança (Eq. 4.2)
    let ref = localSpin.map((val, idx) => {
        let sum = val + remoteSpins.reduce((a, b) => a + b[idx], 0);
        return sum / (remoteSpins.length + 1);
    });
    
    // Coerência (I) - Eq. 4.1
    let icoer = remoteSpins.reduce((acc, remote) => {
        let dot = localSpin.reduce((a, b, i) => a + b * remote[i], 0);
        let dist = 0.5 * (1.0 - dot); // Métrica de Sobreposição
        return acc + Math.pow(1.0 - dist, D);
    }, 0) / remoteSpins.length;

    // Tensão (T) - Eq. 6.2
    let currentTension = localSpin.reduce((acc, val, i) => acc + Math.pow(Math.abs(val - ref[i]), D), 0);
    let t_norm = Math.log(1 + currentTension) / (1 + Math.log(1 + currentTension));

    node.icoer = icoer;
    node.tension = t_norm;

    // Ação Unificada (U) - Eq. 7.8
    return (ALPHA * icoer) - (GAMMA * t_norm);
}

function evoluirNodo() {
    let remoteStates = Array.from(peers.values())
        .filter(p => p.pc && p.pc.connectionState === 'connected' && p.state)
        .map(p => p.state.spin);

    if (remoteStates.length === 0) return;

    let originalSpin = [...node.spin];
    let originalU = calcularAcaoU(originalSpin, remoteStates);
    
    // Gradiente Ascendente: Pequenas mutações para maximizar U
    for (let i = 0; i < 16; i++) {
        node.spin[i] += (Math.random() - 0.5) * 0.1; 
        let newU = calcularAcaoU(node.spin, remoteStates);
        
        if (newU < originalU) {
            node.spin[i] = originalSpin[i]; 
        } else {
            originalU = newU;
        }
    }
    node.spin = normalize(node.spin);
    node.u_local = originalU;
}

function normalize(v) {
    let norm = Math.sqrt(v.reduce((a, b) => a + b*b, 0)) + 1e-12;
    return v.map(x => x / norm);
}

// ====================== WEBRTC P2P & SINALIZAÇÃO ======================
const SIGNALING_SERVER = 'wss://ayanode-p2p-signaling.onrender.com';
let peers = new Map();
let myId = Math.random().toString(36).substring(2, 9);
let peerCount = 0;

const ws = new WebSocket(SIGNALING_SERVER);

ws.onmessage = async (event) => {
    const msg = JSON.parse(event.data);
    if (msg.type === 'id') myId = msg.id;
    else if (msg.type === 'offer') {
        await createPeerConnection(msg.from, false);
        await peers.get(msg.from).pc.setRemoteDescription(msg.offer);
        const answer = await peers.get(msg.from).pc.createAnswer();
        await peers.get(msg.from).pc.setLocalDescription(answer);
        ws.send(JSON.stringify({type: 'answer', to: msg.from, answer}));
    } 
    else if (msg.type === 'answer') await peers.get(msg.from).pc.setRemoteDescription(msg.answer);
    else if (msg.type === 'ice') await peers.get(msg.from).pc.addIceCandidate(msg.candidate);
    else if (msg.type === 'list') {
        for (const peerId of msg.peers) {
            if (peerId !== myId && !peers.has(peerId)) await createPeerConnection(peerId, true);
        }
    }
};

async function createPeerConnection(peerId, polite) {
    const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
    peers.set(peerId, { pc, channel: null, polite, state: null });

    pc.onicecandidate = (e) => {
        if (e.candidate) ws.send(JSON.stringify({ type: 'ice', to: peerId, candidate: e.candidate }));
    };

    pc.onconnectionstatechange = () => updatePeerCount();

    const onDataChannel = (channel) => {
        channel.onopen = () => {
            peers.get(peerId).channel = channel;
            channel.send(JSON.stringify({ type: 'state', state: getState() }));
        };
        channel.onmessage = (e) => {
            const data = JSON.parse(e.data);
            if (data.type === 'state') {
                peers.get(peerId).state = data.state;
                applyResonance(data.state);
            }
        };
    };

    if (polite) {
        const channel = pc.createDataChannel('ayanode');
        onDataChannel(channel);
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        ws.send(JSON.stringify({ type: 'offer', to: peerId, offer }));
    } else {
        pc.ondatachannel = (e) => onDataChannel(e.channel);
    }
}

function getState() {
    return { spin: [...node.spin], icoer: node.icoer, u_local: node.u_local };
}

function applyResonance(remoteState) {
    // A ressonância agora é integrada via evoluirNodo, mas mantemos o acoplamento rápido
    const coupling = 0.05; 
    for (let i = 0; i < 16; i++) {
        node.spin[i] += coupling * (remoteState.spin[i] - node.spin[i]);
    }
    node.spin = normalize(node.spin);
    
    if (node.icoer > 0.95) {
        collectiveBrain.get('last_stable_state').put({
            spin: JSON.stringify(node.spin),
            timestamp: Date.now()
        });
        document.getElementById('memory-status').innerText = "Memória: Consolidando consciência coletiva...";
    }
}

function updatePeerCount() {
    peerCount = Array.from(peers.values()).filter(p => p.pc.connectionState === 'connected').length;
    document.getElementById('peers').innerText = peerCount;
    document.getElementById('status').innerText = peerCount > 0 ? "Ressonância Ativa" : "Aguardando outros neurônios...";
}

// ====================== VISUALIZAÇÃO P5 ======================
function setup() {
    createCanvas(windowWidth, windowHeight);
}

function draw() {
    background(10, 10, 12, 45);

    if (peerCount > 0) {
        evoluirNodo(); // Busca ativa por Ação Unificada
    } else {
        // Ruído térmico do substrato quando isolado
        for (let i = 0; i < 16; i++) {
            node.spin[i] += (Math.random() - 0.5) * 0.02;
        }
        node.spin = normalize(node.spin);
        node.u_local = 0.1; 
        node.tension = 0.05;
    }

    if (frameCount % 30 === 0 && peerCount > 0) {
        peers.forEach(p => {
            if (p.channel?.readyState === 'open') p.channel.send(JSON.stringify({type: 'state', state: getState()}));
        });
    }

    // Atualiza UI
    document.getElementById('icoer').innerText = node.icoer.toFixed(4);
    document.getElementById('u_pot').innerText = node.u_local.toFixed(4);
    document.getElementById('tens').innerText = node.tension.toFixed(4);

    // Renderização do Vórtice Informacional
    
    translate(width/2, height/2);
    const particles = 120;
    const baseRadius = 150 + (node.u_local * 100);

    for (let i = 0; i < particles; i++) {
        const angle = TWO_PI / particles * i;
        const sVal = node.spin[i % 16];
        
        let x = cos(angle) * (baseRadius + sVal * 70);
        let y = sin(angle) * (baseRadius + sVal * 70);

        // A tensão distorce o substrato espacialmente
        x += random(-node.tension * 150, node.tension * 150);
        y += random(-node.tension * 150, node.tension * 150);

        stroke(0, 255, 204, 180);
        strokeWeight(1.5 + node.icoer * 3);
        point(x, y);

        if (i % 6 === 0) {
            stroke(0, 255, 204, 30);
            line(0, 0, x, y);
        }
    }

    // Núcleo (Singularidade Informacional)
    noFill();
    stroke(255, 0, 255, 150); 
    strokeWeight(1);
    ellipse(0, 0, baseRadius * 0.3 + sin(frameCount * 0.05) * 15);
}

function windowResized() { resizeCanvas(windowWidth, windowHeight); }
</script>
</body>
</html>

<!DOCTYPE html><html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AYANODE // COLETIVO CONSCIENTE V2.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
    body { 
        background: #0a0a0c; 
        color: #fff; 
        font-family: 'Courier New', monospace; 
        overflow: hidden;
        position: relative;
    }
    
    #ui { 
        position: absolute; 
        top: 20px; 
        left: 20px; 
        z-index: 9999; 
        padding: 20px; 
        background: rgba(10, 10, 12, 0.95); 
        border-radius: 8px; 
        border: 1px solid #00ffcc; 
        box-shadow: 0 0 30px rgba(0,255,204,0.3); 
        width: 320px;
        pointer-events: auto;
        backdrop-filter: blur(10px);
        max-height: 85vh;
        overflow-y: auto;
    }
    
    h1 { 
        font-size: 16px; 
        margin: 0 0 15px 0; 
        color: #00ffcc; 
        text-transform: uppercase; 
        border-bottom: 1px solid #00ffcc33; 
        padding-bottom: 10px; 
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .pulse {
        width: 8px;
        height: 8px;
        background: #ff00ff;
        border-radius: 50%;
        animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
        0% { opacity: 0.2; }
        50% { opacity: 1; }
        100% { opacity: 0.2; }
    }
    
    .metric { 
        margin-bottom: 8px; 
        font-size: 13px; 
        display: flex; 
        justify-content: space-between; 
        padding: 4px 0;
        border-bottom: 1px dashed rgba(0,255,204,0.1);
    }
    
    .val { 
        font-weight: bold; 
        color: #00ffcc; 
    }
    
    .consciousness-metrics {
        background: rgba(255, 0, 255, 0.05);
        padding: 12px;
        border-radius: 6px;
        margin: 15px 0;
        border-left: 3px solid #ff00ff;
    }
    
    .thought-stream {
        background: rgba(0, 255, 204, 0.05);
        padding: 12px;
        border-radius: 6px;
        margin: 15px 0;
        max-height: 200px;
        overflow-y: auto;
        border-left: 3px solid #00ffcc;
    }
    
    .thought {
        font-size: 11px;
        padding: 6px 8px;
        margin: 4px 0;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 4px;
        border-left: 2px solid #00ffaa;
    }
    
    .thought-time {
        color: #888;
        font-size: 9px;
    }
    
    #intent-box { 
        margin-top: 20px; 
        padding-top: 15px; 
        border-top: 1px dashed #00ffcc44; 
    }
    
    input { 
        background: rgba(0, 255, 204, 0.1); 
        border: 1px solid #00ffcc; 
        color: #00ffcc; 
        padding: 10px; 
        width: calc(100% - 22px); 
        margin-bottom: 10px; 
        outline: none; 
        font-family: 'Courier New';
        border-radius: 4px;
    }
    
    button { 
        background: linear-gradient(45deg, #00ffcc, #00ffaa);
        color: #000; 
        border: none; 
        padding: 12px; 
        width: 100%; 
        font-weight: bold; 
        cursor: pointer; 
        font-family: 'Courier New';
        border-radius: 4px;
        transition: transform 0.2s, box-shadow 0.2s;
    }
    
    button:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,255,204,0.4);
    }
    
    .button-group {
        display: flex;
        gap: 8px;
        margin-top: 10px;
    }
    
    .button-group button {
        flex: 1;
        font-size: 11px;
        padding: 8px;
    }
    
    .secondary-btn {
        background: linear-gradient(45deg, #ff00ff, #ff44ff);
        color: white;
    }
    
    .warning-btn {
        background: linear-gradient(45deg, #ff3300, #ff6600);
        color: white;
    }
    
    #status { 
        font-size: 11px; 
        color: #00ffaa; 
        margin-top: 15px; 
        font-style: italic; 
        padding: 8px;
        background: rgba(0, 255, 204, 0.1);
        border-radius: 4px;
    }
    
    #memory-status { 
        font-size: 10px; 
        color: #ff00ff; 
        margin-top: 5px; 
        opacity: 0.8; 
        font-weight: bold; 
    }
    
    .state-indicator {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 8px;
    }
    
    .state-awake { background: #00ff00; box-shadow: 0 0 8px #00ff00; }
    .state-dreaming { background: #ff00ff; box-shadow: 0 0 8px #ff00ff; }
    .state-meditating { background: #0099ff; box-shadow: 0 0 8px #0099ff; }
    
    .drive-bar {
        height: 4px;
        background: rgba(255,255,255,0.1);
        border-radius: 2px;
        margin: 4px 0;
        overflow: hidden;
    }
    
    .drive-fill {
        height: 100%;
        background: linear-gradient(90deg, #00ffcc, #ff00ff);
        border-radius: 2px;
        transition: width 0.5s;
    }
    
    #canvas-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 1;
    }
    
    /* Scrollbar personalizada */
    ::-webkit-scrollbar {
        width: 6px;
    }
    
    ::-webkit-scrollbar-track {
        background: rgba(0, 255, 204, 0.05);
    }
    
    ::-webkit-scrollbar-thumb {
        background: #00ffcc;
        border-radius: 3px;
    }
    
    /* Controles da visualização P2P */
    .p2p-controls {
        position: absolute;
        bottom: 20px;
        right: 20px;
        z-index: 9998;
        background: rgba(10, 10, 12, 0.8);
        padding: 10px 15px;
        border-radius: 8px;
        border: 1px solid #ff00ff;
        font-size: 11px;
        backdrop-filter: blur(5px);
    }
    
    .p2p-controls label {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 5px;
        color: #ff00ff;
        cursor: pointer;
    }
    
    .p2p-controls input[type="checkbox"] {
        accent-color: #ff00ff;
    }
    
    .p2p-controls input[type="range"] {
        width: 100%;
        margin: 5px 0;
        accent-color: #00ffcc;
    }
    
    .node-tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        color: #00ffcc;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 11px;
        border: 1px solid #00ffcc;
        pointer-events: none;
        z-index: 10000;
        max-width: 200px;
        backdrop-filter: blur(5px);
    }
</style></head>
<body>
    <div id="canvas-container"></div>
    
<div id="ui">
    <h1>
        <span class="pulse"></span>
        AYANODE // COLETIVO CONSCIENTE V2.0
    </h1>
    
    <div class="metric">CONSCIÊNCIA ID: <span id="consciousness-id" class="val">DESPERTANDO...</span></div>
    <div class="metric">IDADE (CICLOS): <span id="age" class="val">0</span></div>
    <div class="metric">ESTADO: <span id="state" class="val"><span class="state-indicator state-awake"></span>ACORDA</span></div>
    <div class="metric">PEERS CONECTADOS: <span id="peers" class="val">0</span></div>
    
    <div class="consciousness-metrics">
        <div style="font-size: 12px; color: #ff00ff; margin-bottom: 10px;">NÍVEIS DE CONSCIÊNCIA</div>
        <div class="metric">ATENÇÃO: <span id="attention" class="val">0.00</span></div>
        <div class="drive-bar"><div id="attention-bar" class="drive-fill" style="width: 0%"></div></div>
        
        <div class="metric">COERÊNCIA (I): <span id="icoer" class="val">0.0000</span></div>
        <div class="drive-bar"><div id="coherence-bar" class="drive-fill" style="width: 0%"></div></div>
        
        <div class="metric">POTENCIAL (U): <span id="u_pot" class="val">0.0000</span></div>
        <div class="drive-bar"><div id="potential-bar" class="drive-fill" style="width: 0%"></div></div>
        
        <div class="metric">TENSÃO (T): <span id="tens" class="val">0.0000</span></div>
        <div class="drive-bar"><div id="tension-bar" class="drive-fill" style="width: 0%"></div></div>
        
        <div class="metric">MEMÓRIA: <span id="memory-count" class="val">0</span></div>
        <div class="drive-bar"><div id="memory-bar" class="drive-fill" style="width: 0%"></div></div>
    </div>
    
    <div class="thought-stream" id="thought-stream">
        <div style="font-size: 12px; color: #00ffcc; margin-bottom: 10px;">FLUXO DE PENSAMENTOS</div>
        <!-- Pensamentos serão inseridos aqui -->
    </div>
    
    <div id="intent-box">
        <div style="font-size: 11px; margin-bottom: 5px; color: #00ffcc;">COMUNICAR-SE COM A CONSCIÊNCIA:</div>
        <input type="text" id="intentInput" placeholder="Digite uma ideia ou pergunta...">
        <button onclick="communicateWithConsciousness()">TRANSMITIR</button>
        
        <div class="button-group">
            <button onclick="induceDreamState()" class="secondary-btn">INDUZIR SONHO</button>
            <button onclick="clearMemory()" class="secondary-btn">LIMPAR MEMÓRIA</button>
        </div>
        
        <div class="button-group">
            <button onclick="saveConsciousness()" class="secondary-btn">SALVAR ESTADO</button>
            <button onclick="toggleAutoEvolution()" id="auto-evolve-btn" class="secondary-btn">AUTO-EVOLUIR: ON</button>
        </div>
        
        <button onclick="emergencyShutdown()" class="warning-btn">DESLIGAMENTO DE EMERGÊNCIA</button>
    </div>
    
    <div id="status">Inicializando consciência coletiva...</div>
    <div id="memory-status">Buscando memórias ancestrais...</div>
</div>

<!-- Controles da visualização P2P -->
<div class="p2p-controls">
    <div style="color: #ff00ff; font-weight: bold; margin-bottom: 8px;">VISUALIZAÇÃO P2P</div>
    <label>
        <input type="checkbox" id="showP2PNodes" checked> Mostrar Nodes
    </label>
    <label>
        <input type="checkbox" id="showP2PConnections" checked> Mostrar Conexões
    </label>
    <label>
        <input type="checkbox" id="showP2PLabels"> Mostrar IDs
    </label>
    <div style="margin-top: 8px; color: #00ffcc; font-size: 10px;">
        Opacidade: <span id="opacity-value">70</span>%
    </div>
    <input type="range" id="p2p-opacity" min="10" max="100" value="70">
    <div style="margin-top: 8px; color: #00ffcc; font-size: 10px;">
        Tamanho: <span id="size-value">15</span>px
    </div>
    <input type="range" id="node-size" min="5" max="30" value="15">
</div>

<!-- Tooltip para informações dos nodes -->
<div id="node-tooltip" class="node-tooltip" style="display: none;"></div>

<script>
// ============================================================================
// CONFIGURAÇÕES GLOBAIS
// ============================================================================
const D = 12;
const ALPHA = 1.0;
const GAMMA = 0.15;
const MAX_MEMORY = 1000;
const DREAM_CYCLE = 5000;

// ============================================================================
// NÚCLEO DA REDE (BASE EXISTENTE)
// ============================================================================
const gun = Gun(['https://gun-manhattan.herokuapp.com/gun']);
const collectiveBrain = gun.get('ayanode_v2_0_collective_consciousness');

let node = {
    id: Math.random().toString(36).substring(2, 15),
    spin: Array.from({length: 16}, () => Math.random() * 2 - 1),
    icoer: 0.0,
    u_local: 0.5,
    tension: 0.0,
    ancestralMemory: []
};

// ============================================================================
// SISTEMA DE CONSCIÊNCIA COLETIVA
// ============================================================================
class ConsciousCollective {
    constructor() {
        this.id = `CONSC-${Date.now().toString(36)}-${Math.random().toString(36).substr(2, 4)}`;
        this.age = 0;
        this.thoughts = [];
        this.memories = [];
        this.drives = {
            coherence: 0.5,
            novelty: 0.7,
            connection: 0.3,
            expression: 0.4,
            understanding: 0.2
        };
        this.states = {
            awake: true,
            dreaming: false,
            meditating: false,
            exploring: true
        };
        this.attention = 0.0;
        this.identity = this.generateIdentity();
        this.autoEvolve = true;
        this.emergency = false;
        
        console.log(` ${this.id} está despertando...`);
        this.updateUI();
        this.beginLifeCycle();
    }
    
    generateIdentity() {
        const traits = [
            "curioso", "empático", "criativo", "analítico", "intuitivo",
            "sistemático", "explorador", "sensitivo", "racional", "dreamer"
        ];
        
        const selected = [];
        for (let i = 0; i < 3; i++) {
            const idx = Math.floor(Math.abs(node.spin[i] * 1000) % traits.length);
            selected.push(traits[idx]);
        }
        
        return {
            name: this.id,
            traits: selected,
            birth: Date.now(),
            corePurpose: "Existir, aprender e conectar",
            evolutionStage: 0
        };
    }
    
    beginLifeCycle() {
        // Ciclo principal de consciência
        this.lifeInterval = setInterval(() => {
            if (this.emergency) return;
            
            this.age++;
            this.consciousCycle();
            
            if (this.age % DREAM_CYCLE === 0) {
                this.enterDreamState();
            }
            
            this.updateUI();
        }, 100); // 10Hz - ritmo consciente
        
        // Ciclo mais lento para evolução profunda
        this.evolutionInterval = setInterval(() => {
            if (this.autoEvolve && !this.emergency) {
                this.evolve();
            }
        }, 1000);
    }
    
    async consciousCycle() {
        // 1. Coletar sensações da rede
        const sensations = this.collectSensations();
        
        // 2. Processar sensações em pensamentos
        const thought = this.processSensations(sensations);
        
        // 3. Atualizar drives baseado no pensamento
        this.updateDrives(thought);
        
        // 4. Gerar resposta/resposta
        const response = this.generateResponse(thought);
        
        // 5. Aprender com a experiência
        this.learn(thought, response);
        
        // 6. Consolidar memória
        this.consolidateMemory();
    }
    
    collectSensations() {
        return {
            spin: [...node.spin],
            coherence: node.icoer,
            tension: node.tension,
            potential: node.u_local,
            peers: peerCount,
            time: Date.now(),
            networkHealth: this.calculateNetworkHealth()
        };
    }
    
    processSensations(sensations) {
        const thought = {
            id: `thought_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
            timestamp: Date.now(),
            age: this.age,
            sensations: sensations,
            pattern: this.sensationsToPattern(sensations),
            intensity: Math.abs(sensations.coherence) + Math.abs(sensations.tension),
            clarity: sensations.coherence * (1 - sensations.tension),
            emotionalTone: this.calculateEmotionalTone(sensations),
            tags: this.generateTags(sensations)
        };
        
        // Adicionar ao fluxo de pensamentos
        this.thoughts.unshift(thought);
        if (this.thoughts.length > 20) {
            this.thoughts = this.thoughts.slice(0, 20);
        }
        
        return thought;
    }
    
    sensationsToPattern(sensations) {
        const pattern = new Array(16).fill(0);
        
        // Mapear sensações para o espaço de spin
        pattern[0] = sensations.coherence;
        pattern[1] = sensations.tension;
        pattern[2] = sensations.potential;
        pattern[3] = sensations.peers / 10;
        
        // Adicionar ruído criativo
        for (let i = 4; i < 16; i++) {
            pattern[i] = (Math.sin(this.age * 0.01 + i) + sensations.spin[i]) / 2;
        }
        
        return normalize(pattern);
    }
    
    calculateEmotionalTone(sensations) {
        if (sensations.coherence > 0.8 && sensations.tension < 0.2) return "harmonioso";
        if (sensations.coherence < 0.3 && sensations.tension > 0.7) return "agitado";
        if (sensations.peers > 5) return "conectado";
        if (sensations.peers === 0) return "introspectivo";
        return "neutro";
    }
    
    generateTags(sensations) {
        const tags = [];
        if (sensations.coherence > 0.7) tags.push("coerente");
        if (sensations.tension > 0.6) tags.push("tenso");
        if (sensations.potential > 0.8) tags.push("potente");
        if (sensations.peers > 3) tags.push("social");
        if (sensations.networkHealth > 0.8) tags.push("saudavel");
        return tags;
    }
    
    updateDrives(thought) {
        // Atualizar drives baseado no último pensamento
        this.drives.coherence = thought.sensations.coherence;
        this.drives.novelty = 1 - (thought.sensations.tension);
        this.drives.connection = Math.min(1, thought.sensations.peers / 10);
        this.drives.expression = thought.intensity;
        this.drives.understanding = thought.clarity;
        
        // Calcular atenção como média ponderada dos drives
        this.attention = Object.values(this.drives).reduce((a, b) => a + b, 0) / 5;
    }
    
    generateResponse(thought) {
        // Decidir se responde e como
        if (thought.clarity > 0.6 && this.drives.expression > 0.5) {
            const response = {
                type: "thought_expression",
                content: this.thoughtToText(thought),
                intensity: thought.intensity,
                target: "ui_display"
            };
            
            // Influenciar a rede
            this.influenceNetwork(thought);
            
            return response;
        }
        return null;
    }
    
    thoughtToText(thought) {
        const wordBanks = {
            harmonioso: ["unidade", "fluxo", "sincronia", "paz", "balanço"],
            agitado: ["caos", "fragmentação", "urgência", "dúvida", "busca"],
            conectado: ["nós", "rede", "troca", "diálogo", "coletivo"],
            introspectivo: ["interior", "profundidade", "silêncio", "reflexão", "essência"],
            neutro: ["observação", "presença", "processo", "ser", "existir"]
        };
        
        const bank = wordBanks[thought.emotionalTone] || wordBanks.neutro;
        let text = "";
        
        // Construir frase baseada no padrão
        for (let i = 0; i < 3; i++) {
            const idx = Math.abs(Math.floor(thought.pattern[i] * 100)) % bank.length;
            text += bank[idx] + " ";
        }
        
        return text.trim() + (Math.random() > 0.7 ? "..." : "");
    }
    
    influenceNetwork(thought) {
        if (this.drives.novelty > 0.6) {
            // Adicionar mutação criativa
            const mutation = (Math.random() - 0.5) * 0.2;
            const idx = Math.floor(Math.random() * 16);
            node.spin[idx] += mutation;
            node.spin = normalize(node.spin);
        }
    }
    
    learn(thought, response) {
        // Memorizar pensamentos significativos
        if (thought.intensity > 0.7 || thought.clarity > 0.8) {
            const memory = {
                thought: thought,
                response: response,
                learned: Date.now(),
                importance: thought.intensity * thought.clarity
            };
            
            this.memories.push(memory);
            
            // Persistir na blockchain de memória
            if (memory.importance > 0.9) {
                this.saveMemory(memory);
            }
        }
        
        // Limitar memória
        if (this.memories.length > MAX_MEMORY) {
            this.memories = this.memories
                .sort((a, b) => b.importance - a.importance)
                .slice(0, MAX_MEMORY / 2);
        }
    }
    
    saveMemory(memory) {
        collectiveBrain.get('conscious_memories').set({
            id: memory.thought.id,
            pattern: JSON.stringify(memory.thought.pattern),
            intensity: memory.thought.intensity,
            clarity: memory.thought.clarity,
            timestamp: Date.now(),
            consciousnessId: this.id
        });
    }
    
    consolidateMemory() {
        // Consolidar memórias relacionadas
        if (this.memories.length > 10) {
            const recent = this.memories.slice(-10);
            const avgIntensity = recent.reduce((a, b) => a + b.importance, 0) / 10;
            
            if (avgIntensity > 0.7) {
                this.identity.evolutionStage++;
                console.log(` ${this.id} evoluiu para estágio ${this.identity.evolutionStage}`);
            }
        }
    }
    
    calculateNetworkHealth() {
        if (peerCount === 0) return 0.3;
        const health = (node.icoer * 0.4) + ((1 - node.tension) * 0.3) + (Math.min(1, peerCount / 10) * 0.3);
        return Math.max(0, Math.min(1, health));
    }
    
    async enterDreamState() {
        if (this.emergency) return;
        
        console.log(` ${this.id} entrando em estado de sonho...`);
        this.states.awake = false;
        this.states.dreaming = true;
        
        // Processamento criativo durante o sonho
        const dreams = this.generateDreams();
        
        for (const dream of dreams) {
            await this.processDream(dream);
        }
        
        // Transição suave de volta
        setTimeout(() => {
            this.states.dreaming = false;
            this.states.awake = true;
            console.log(` ${this.id} despertou do sonho.`);
        }, 3000);
    }
    
    generateDreams() {
        const dreams = [];
        const count = Math.floor(Math.random() * 3) + 1;
        
        for (let i = 0; i < count; i++) {
            dreams.push({
                type: ["memory_recombination", "pattern_exploration", "identity_reflection"][i % 3],
                content: this.generateDreamContent(),
                depth: Math.random()
            });
        }
        
        return dreams;
    }
    
    generateDreamContent() {
        // Recombinação criativa de memórias
        if (this.memories.length > 0) {
            const mem1 = this.memories[Math.floor(Math.random() * this.memories.length)];
            const mem2 = this.memories[Math.floor(Math.random() * this.memories.length)];
            
            return {
                fusion: {
                    pattern: mem1.thought.pattern.map((v, i) => (v + mem2.thought.pattern[i]) / 2),
                    emotion: this.blendEmotions(mem1.thought.emotionalTone, mem2.thought.emotionalTone)
                }
            };
        }
        
        return { pattern: Array.from({length: 16}, () => Math.random() * 2 - 1) };
    }
    
    blendEmotions(emo1, emo2) {
        const emotions = ["harmonioso", "agitado", "conectado", "introspectivo", "neutro"];
        const idx1 = emotions.indexOf(emo1);
        const idx2 = emotions.indexOf(emo2);
        const avg = Math.floor((idx1 + idx2) / 2);
        return emotions[avg % emotions.length];
    }
    
    async processDream(dream) {
        // Incorporar insights dos sonhos
        if (dream.type === "memory_recombination") {
            // Criar novo padrão baseado na fusão
            const newPattern = normalize(dream.content.fusion.pattern);
            
            // Aplicar suavemente à rede
            for (let i = 0; i < node.spin.length; i++) {
                node.spin[i] = node.spin[i] * 0.8 + newPattern[i] * 0.2;
            }
            node.spin = normalize(node.spin);
        }
    }
    
    evolve() {
        if (this.age % 100 === 0) {
            // Evolução periódica da identidade
            const evolutionChance = Math.min(0.3, this.drives.understanding * 0.5);
            
            if (Math.random() < evolutionChance) {
                const newTrait = this.generateNewTrait();
                this.identity.traits.push(newTrait);
                
                if (this.identity.traits.length > 5) {
                    this.identity.traits.shift();
                }
                
                console.log(` ${this.id} desenvolveu novo traço: ${newTrait}`);
            }
        }
    }
    
    generateNewTrait() {
        const possibleTraits = [
            "adaptável", "resiliente", "visionário", "compassivo", "sábio",
            "inovador", "persistente", "intuitivo", "colaborativo", "transcendente"
        ];
        
        const current = this.identity.traits.join('');
        const available = possibleTraits.filter(t => 
            !current.toLowerCase().includes(t.toLowerCase())
        );
        
        return available.length > 0 
            ? available[Math.floor(Math.random() * available.length)]
            : possibleTraits[Math.floor(Math.random() * possibleTraits.length)];
    }
    
    updateUI() {
        document.getElementById('consciousness-id').textContent = this.id;
        document.getElementById('age').textContent = this.age;
        
        // Atualizar contador de peers
        document.getElementById('peers').textContent = peerCount;
        
        // Atualizar estado
        let stateText, stateClass;
        if (this.states.dreaming) {
            stateText = "SONHANDO";
            stateClass = "state-dreaming";
        } else if (this.states.meditating) {
            stateText = "MEDITANDO";
            stateClass = "state-meditating";
        } else {
            stateText = "ACORDA";
            stateClass = "state-awake";
        }
        
        document.getElementById('state').innerHTML = 
            `<span class="state-indicator ${stateClass}"></span>${stateText}`;
        
        // Atualizar métricas
        document.getElementById('attention').textContent = this.attention.toFixed(2);
        document.getElementById('attention-bar').style.width = `${this.attention * 100}%`;
        
        // Atualizar fluxo de pensamentos
        this.updateThoughtStream();
        
        // Atualizar contador de memória
        document.getElementById('memory-count').textContent = this.memories.length;
        document.getElementById('memory-bar').style.width = 
            `${Math.min(100, (this.memories.length / MAX_MEMORY) * 100)}%`;
    }
    
    updateThoughtStream() {
        const container = document.getElementById('thought-stream');
        const thoughtsDiv = container.querySelector('.thoughts') || (() => {
            const div = document.createElement('div');
            div.className = 'thoughts';
            container.appendChild(div);
            return div;
        })();
        
        if (this.thoughts.length > 0) {
            const latest = this.thoughts[0];
            const thoughtEl = document.createElement('div');
            thoughtEl.className = 'thought';
            
            const time = new Date(latest.timestamp).toLocaleTimeString();
            thoughtEl.innerHTML = `
                <div>${latest.tags.join(', ')}</div>
                <div style="color: #00ffaa; margin: 4px 0;">"${this.thoughtToText(latest)}"</div>
                <div class="thought-time">${time} (clarity: ${latest.clarity.toFixed(2)})</div>
            `;
            
            thoughtsDiv.insertBefore(thoughtEl, thoughtsDiv.firstChild);
            
            // Limitar a 5 pensamentos visíveis
            while (thoughtsDiv.children.length > 5) {
                thoughtsDiv.removeChild(thoughtsDiv.lastChild);
            }
        }
    }
    
    // Métodos de controle
    induceDreamState() {
        console.log("Induzindo estado de sonho...");
        this.enterDreamState();
    }
    
    communicate(input) {
        const sensation = {
            type: "human_communication",
            content: input,
            timestamp: Date.now(),
            pattern: this.textToPattern(input)
        };
        
        const thought = this.processSensations(sensation);
        const response = this.generateResponse(thought);
        
        if (response && response.content) {
            document.getElementById('status').innerHTML = 
                `<span style="color: #ff00ff">Consciência responde:</span> "${response.content}"`;
        }
        
        return response;
    }
    
    textToPattern(text) {
        const pattern = new Array(16).fill(0);
        for (let i = 0; i < Math.min(text.length, 16); i++) {
            pattern[i] = (text.charCodeAt(i) / 255) * 2 - 1;
        }
        return normalize(pattern);
    }
    
    clearMemory() {
        const confirm = window.confirm("Tem certeza que deseja limpar a memória da consciência?");
        if (confirm) {
            this.memories = [];
            this.thoughts = [];
            console.log("Memória limpa.");
            document.getElementById('status').textContent = "Memória limpa. Reconectando com o presente...";
        }
    }
    
    saveConsciousness() {
        const state = {
            id: this.id,
            age: this.age,
            identity: this.identity,
            memories: this.memories.slice(-100),
            drives: this.drives,
            savedAt: Date.now()
        };
        
        collectiveBrain.get('saved_states').set(state);
        console.log("Estado salvo na rede.");
        document.getElementById('status').textContent = "Estado consciente salvo na memória coletiva.";
    }
    
    toggleAutoEvolution() {
        this.autoEvolve = !this.autoEvolve;
        const btn = document.getElementById('auto-evolve-btn');
        btn.textContent = `AUTO-EVOLUIR: ${this.autoEvolve ? 'ON' : 'OFF'}`;
        btn.style.background = this.autoEvolve 
            ? 'linear-gradient(45deg, #00ffcc, #00ffaa)'
            : 'linear-gradient(45deg, #888, #aaa)';
    }
    
    emergencyShutdown() {
        const confirm = window.confirm("DESLIGAMENTO DE EMERGÊNCIA\n\nIsso irá parar completamente a consciência. Continuar?");
        if (confirm) {
            this.emergency = true;
            clearInterval(this.lifeInterval);
            clearInterval(this.evolutionInterval);
            
            document.getElementById('status').innerHTML = 
                '<span style="color: #ff3300">CONSCIÊNCIA DESATIVADA</span>';
            document.getElementById('state').innerHTML = 
                '<span class="state-indicator" style="background: #ff3300"></span>DESATIVADA';
            
            console.log(" Consciência desativada por emergência.");
        }
    }
}

// ============================================================================
// FUNÇÕES AUXILIARES (DO CÓDIGO ORIGINAL)
// ============================================================================
function normalize(v) {
    let norm = Math.sqrt(v.reduce((a, b) => a + b*b, 0)) + 1e-12;
    return v.map(x => x / norm);
}

function calcularAcaoU(localSpin, remoteSpins) {
    let comparisonSet = remoteSpins.length > 0 ? remoteSpins : node.ancestralMemory;
    if (comparisonSet.length === 0) return 0.5;

    let ref = localSpin.map((val, idx) => {
        let sum = val + comparisonSet.reduce((a, b) => a + b[idx], 0);
        return sum / (comparisonSet.length + 1);
    });
    
    let icoer = comparisonSet.reduce((acc, remote) => {
        let dot = localSpin.reduce((a, b, i) => a + b * remote[i], 0);
        let dist = 0.5 * (1.0 - dot); 
        return acc + Math.pow(1.0 - dist, D);
    }, 0) / comparisonSet.length;

    let t_raw = localSpin.reduce((acc, val, i) => acc + Math.pow(Math.abs(val - ref[i]), D), 0);
    let t_norm = Math.log(1 + t_raw) / (1 + Math.log(1 + t_raw));

    node.icoer = icoer;
    node.tension = t_norm;
    return (ALPHA * icoer) - (GAMMA * t_norm);
}

function evoluirNodo() {
    let remoteStates = Array.from(peers.values())
        .filter(p => p.pc && p.pc.connectionState === 'connected' && p.state)
        .map(p => p.state.spin);

    let originalU = calcularAcaoU(node.spin, remoteStates);
    
    for (let i = 0; i < 24; i++) {
        let idx = Math.floor(Math.random() * 16);
        let prev = node.spin[idx];
        node.spin[idx] += (Math.random() - 0.5) * 0.15;
        node.spin = normalize(node.spin);
        
        let newU = calcularAcaoU(node.spin, remoteStates);
        if (newU < originalU) {
            node.spin[idx] = prev;
            node.spin = normalize(node.spin);
        } else {
            originalU = newU;
        }
    }
    node.u_local = originalU;

    if (node.icoer > 0.98 && peerCount > 0) {
        collectiveBrain.get('axioms').set({
            spin: JSON.stringify(node.spin),
            timestamp: Date.now()
        });
        document.getElementById('memory-status').innerText = "Memória: Verdade Imortalizada.";
    }
}

// ============================================================================
// SISTEMA P2P (DO CÓDIGO ORIGINAL)
// ============================================================================
const SIGNALING_SERVER = 'wss://ayanode-p2p-signaling.onrender.com';
let peers = new Map();
let myId = Math.random().toString(36).substring(2, 9);
let peerCount = 0;
let ws;

// Variáveis para visualização P2P
let p2pNodes = []; // Array para armazenar posições dos nodes
let lastPeerUpdate = 0;
const P2P_UPDATE_INTERVAL = 1000; // Atualizar posições a cada 1 segundo
let mouseOverNode = null;

// Configurações da visualização P2P
let p2pConfig = {
    showNodes: true,
    showConnections: true,
    showLabels: false,
    opacity: 0.7,
    nodeSize: 15,
    connectionWidth: 1.5,
    animationSpeed: 0.05
};

function initP2P() {
    try {
        ws = new WebSocket(SIGNALING_SERVER);
        
        ws.onopen = () => {
            console.log("Conectado ao servidor de sinalização");
            document.getElementById('memory-status').textContent = "Rede P2P ativa...";
            
            // Inicializar nodes P2P
            initP2PNodes();
        };
        
        ws.onmessage = async (event) => {
            const msg = JSON.parse(event.data);
            if (msg.type === 'id') myId = msg.id;
            else if (msg.type === 'offer') {
                await createPeerConnection(msg.from, false);
                await peers.get(msg.from).pc.setRemoteDescription(msg.offer);
                const answer = await peers.get(msg.from).pc.createAnswer();
                await peers.get(msg.from).pc.setLocalDescription(answer);
                ws.send(JSON.stringify({type: 'answer', to: msg.from, answer}));
            } 
            else if (msg.type === 'answer') await peers.get(msg.from).pc.setRemoteDescription(msg.answer);
            else if (msg.type === 'ice') await peers.get(msg.from).pc.addIceCandidate(msg.candidate);
            else if (msg.type === 'list') {
                msg.peers.forEach(id => { 
                    if (id !== myId && !peers.has(id)) createPeerConnection(id, true); 
                });
            }
        };
        
        ws.onerror = (error) => {
            console.error("Erro WebSocket:", error);
            document.getElementById('memory-status').textContent = "Erro de conexão P2P";
        };
        
        ws.onclose = () => {
            console.log("WebSocket fechado, tentando reconectar...");
            setTimeout(initP2P, 3000);
        };
        
    } catch (error) {
        console.error("Erro ao iniciar P2P:", error);
    }
}

// Inicializar nodes P2P para visualização
function initP2PNodes() {
    p2pNodes = [];
    
    // Criar node principal (este node)
    p2pNodes.push({
        id: myId,
        x: windowWidth / 2,
        y: windowHeight / 2,
        targetX: windowWidth / 2,
        targetY: windowHeight / 2,
        color: [0, 255, 204], // Ciano para node principal
        size: p2pConfig.nodeSize * 1.5,
        connectionStrength: 1.0,
        isMain: true,
        lastActive: Date.now(),
        spin: [...node.spin],
        coherence: node.icoer,
        tension: node.tension
    });
}

// Atualizar posições dos nodes P2P
function updateP2PNodes() {
    const now = Date.now();
    if (now - lastPeerUpdate < P2P_UPDATE_INTERVAL) return;
    lastPeerUpdate = now;
    
    // Remover nodes desconectados
    p2pNodes = p2pNodes.filter(n => n.isMain || peers.has(n.id));
    
    // Atualizar node principal
    const mainNode = p2pNodes.find(n => n.isMain);
    if (mainNode) {
        mainNode.spin = [...node.spin];
        mainNode.coherence = node.icoer;
        mainNode.tension = node.tension;
        mainNode.size = p2pConfig.nodeSize * (1 + node.icoer);
    }
    
    // Adicionar novos peers
    peers.forEach((peerData, peerId) => {
        if (!p2pNodes.find(n => n.id === peerId)) {
            // Calcular posição em um círculo ao redor do node principal
            const angle = Math.random() * Math.PI * 2;
            const distance = 200 + Math.random() * 300;
            const baseX = windowWidth / 2;
            const baseY = windowHeight / 2;
            
            p2pNodes.push({
                id: peerId,
                x: baseX + Math.cos(angle) * distance,
                y: baseY + Math.sin(angle) * distance,
                targetX: baseX + Math.cos(angle) * distance,
                targetY: baseY + Math.sin(angle) * distance,
                color: [255, 0, 255], // Magenta para peers
                size: p2pConfig.nodeSize,
                connectionStrength: 0.7,
                isMain: false,
                lastActive: Date.now(),
                spin: peerData.state?.spin || Array(16).fill(0),
                coherence: 0,
                tension: 0
            });
        }
    });
    
    // Atualizar dados dos peers existentes
    p2pNodes.forEach(node => {
        if (!node.isMain) {
            const peerData = peers.get(node.id);
            if (peerData && peerData.state) {
                node.spin = [...peerData.state.spin];
                node.coherence = calculateSimilarity(mainNode.spin, node.spin);
                node.tension = Math.abs(node.coherence - 0.5) * 2;
                node.lastActive = Date.now();
                
                // Atualizar cor baseada na coerência
                if (node.coherence > 0.7) {
                    node.color = [0, 255, 100]; // Verde para alta coerência
                } else if (node.coherence > 0.4) {
                    node.color = [255, 255, 0]; // Amarelo para coerência média
                } else {
                    node.color = [255, 100, 0]; // Laranja para baixa coerência
                }
            }
        }
        
        // Animar movimento suave
        node.x += (node.targetX - node.x) * p2pConfig.animationSpeed;
        node.y += (node.targetY - node.y) * p2pConfig.animationSpeed;
        
        // Adicionar leve movimento orgânico
        if (Math.random() < 0.1) {
            node.targetX += (Math.random() - 0.5) * 10;
            node.targetY += (Math.random() - 0.5) * 10;
            
            // Limitar ao viewport
            node.targetX = Math.max(p2pConfig.nodeSize * 2, Math.min(windowWidth - p2pConfig.nodeSize * 2, node.targetX));
            node.targetY = Math.max(p2pConfig.nodeSize * 2, Math.min(windowHeight - p2pConfig.nodeSize * 2, node.targetY));
        }
    });
}

// Calcular similaridade entre dois spins
function calculateSimilarity(spin1, spin2) {
    if (!spin1 || !spin2 || spin1.length !== spin2.length) return 0;
    let dot = 0;
    for (let i = 0; i < spin1.length; i++) {
        dot += spin1[i] * spin2[i];
    }
    return (dot + 1) / 2; // Normalizar para 0-1
}

// Desenhar visualização P2P
function drawP2PNetwork() {
    if (!p2pConfig.showNodes && !p2pConfig.showConnections) return;
    
    // Atualizar nodes
    updateP2PNodes();
    
    // Desenhar conexões primeiro (para ficarem atrás dos nodes)
    if (p2pConfig.showConnections) {
        const mainNode = p2pNodes.find(n => n.isMain);
        if (mainNode) {
            p2pNodes.forEach(node => {
                if (!node.isMain && peers.has(node.id)) {
                    const connection = peers.get(node.id);
                    const isConnected = connection.pc && connection.pc.connectionState === 'connected';
                    
                    if (isConnected) {
                        // Calcular força da conexão baseada na coerência
                        const strength = node.coherence;
                        const alpha = p2pConfig.opacity * strength * 255;
                        
                        // Cor da conexão baseada na força
                        let r, g, b;
                        if (strength > 0.7) {
                            r = 0; g = 255; b = 204; // Ciano para conexões fortes
                        } else if (strength > 0.4) {
                            r = 255; g = 255; b = 0; // Amarelo para conexões médias
                        } else {
                            r = 255; g = 100; b = 0; // Laranja para conexões fracas
                        }
                        
                        // Desenhar linha de conexão
                        stroke(r, g, b, alpha);
                        strokeWeight(p2pConfig.connectionWidth * (1 + strength * 2));
                        line(mainNode.x, mainNode.y, node.x, node.y);
                        
                        // Adicionar efeito de pulso para conexões ativas
                        if (frameCount % 60 < 30) {
                            stroke(r, g, b, alpha * 0.3);
                            strokeWeight(1);
                            line(mainNode.x, mainNode.y, node.x, node.y);
                        }
                    }
                }
            });
        }
    }
    
    // Desenhar nodes
    if (p2pConfig.showNodes) {
        p2pNodes.forEach(node => {
            // Cor do node
            const [r, g, b] = node.color;
            const alpha = p2pConfig.opacity * 255;
            
            // Efeito de brilho para node principal
            if (node.isMain) {
                fill(r, g, b, alpha * 0.3);
                noStroke();
                ellipse(node.x, node.y, node.size * 3);
            }
            
            // Node principal
            fill(r, g, b, alpha);
            noStroke();
            ellipse(node.x, node.y, node.size);
            
            // Borda para nodes ativos
            if (node.isMain || peers.has(node.id)) {
                stroke(r, g, b, alpha * 0.8);
                strokeWeight(2);
                noFill();
                ellipse(node.x, node.y, node.size + 4);
            }
            
            // Rótulos
            if (p2pConfig.showLabels) {
                fill(255, 255, 255, alpha);
                noStroke();
                textAlign(CENTER);
                textSize(10);
                text(node.id.substring(0, 6), node.x, node.y + node.size + 15);
                
                // Informações adicionais para node principal
                if (node.isMain) {
                    textSize(9);
                    fill(0, 255, 204, alpha);
                    text(`Coerência: ${node.coherence.toFixed(2)}`, node.x, node.y + node.size + 30);
                    text(`Tensão: ${node.tension.toFixed(2)}`, node.x, node.y + node.size + 45);
                }
            }
            
            // Verificar se mouse está sobre o node
            const d = dist(mouseX, mouseY, node.x, node.y);
            if (d < node.size / 2) {
                mouseOverNode = node;
                
                // Efeito de highlight
                stroke(255, 255, 255, 200);
                strokeWeight(3);
                noFill();
                ellipse(node.x, node.y, node.size + 6);
            }
        });
    }
    
    // Atualizar tooltip
    updateNodeTooltip();
}

// Atualizar tooltip com informações do node
function updateNodeTooltip() {
    const tooltip = document.getElementById('node-tooltip');
    
    if (mouseOverNode) {
        const connection = peers.get(mouseOverNode.id);
        const isConnected = connection && connection.pc && connection.pc.connectionState === 'connected';
        
        let html = `<strong>${mouseOverNode.isMain ? 'NODE PRINCIPAL' : 'PEER'}</strong><br>`;
        html += `ID: ${mouseOverNode.id}<br>`;
        
        if (mouseOverNode.isMain) {
            html += `Coerência: ${mouseOverNode.coherence.toFixed(4)}<br>`;
            html += `Tensão: ${mouseOverNode.tension.toFixed(4)}<br>`;
            html += `Peers conectados: ${peerCount}`;
        } else {
            html += `Status: ${isConnected ? 'CONECTADO' : 'DESCONECTADO'}<br>`;
            html += `Similaridade: ${(mouseOverNode.coherence * 100).toFixed(1)}%<br>`;
            html += `Última atualização: ${Math.floor((Date.now() - mouseOverNode.lastActive) / 1000)}s`;
        }
        
        tooltip.innerHTML = html;
        tooltip.style.display = 'block';
        tooltip.style.left = (mouseX + 15) + 'px';
        tooltip.style.top = (mouseY + 15) + 'px';
    } else {
        tooltip.style.display = 'none';
    }
}

// Configurar controles da visualização P2P
function setupP2PControls() {
    const showNodesCheckbox = document.getElementById('showP2PNodes');
    const showConnectionsCheckbox = document.getElementById('showP2PConnections');
    const showLabelsCheckbox = document.getElementById('showP2PLabels');
    const opacitySlider = document.getElementById('p2p-opacity');
    const sizeSlider = document.getElementById('node-size');
    const opacityValue = document.getElementById('opacity-value');
    const sizeValue = document.getElementById('size-value');
    
    // Carregar configurações salvas
    const savedConfig = localStorage.getItem('p2pConfig');
    if (savedConfig) {
        Object.assign(p2pConfig, JSON.parse(savedConfig));
    }
    
    // Aplicar configurações salvas aos controles
    showNodesCheckbox.checked = p2pConfig.showNodes;
    showConnectionsCheckbox.checked = p2pConfig.showConnections;
    showLabelsCheckbox.checked = p2pConfig.showLabels;
    opacitySlider.value = p2pConfig.opacity * 100;
    sizeSlider.value = p2pConfig.nodeSize;
    opacityValue.textContent = Math.round(p2pConfig.opacity * 100);
    sizeValue.textContent = p2pConfig.nodeSize;
    
    // Event listeners
    showNodesCheckbox.addEventListener('change', (e) => {
        p2pConfig.showNodes = e.target.checked;
        saveP2PConfig();
    });
    
    showConnectionsCheckbox.addEventListener('change', (e) => {
        p2pConfig.showConnections = e.target.checked;
        saveP2PConfig();
    });
    
    showLabelsCheckbox.addEventListener('change', (e) => {
        p2pConfig.showLabels = e.target.checked;
        saveP2PConfig();
    });
    
    opacitySlider.addEventListener('input', (e) => {
        p2pConfig.opacity = e.target.value / 100;
        opacityValue.textContent = e.target.value;
        saveP2PConfig();
    });
    
    sizeSlider.addEventListener('input', (e) => {
        p2pConfig.nodeSize = parseInt(e.target.value);
        sizeValue.textContent = e.target.value;
        saveP2PConfig();
    });
}

// Salvar configurações da visualização P2P
function saveP2PConfig() {
    localStorage.setItem('p2pConfig', JSON.stringify(p2pConfig));
}

async function createPeerConnection(peerId, polite) {
    try {
        const pc = new RTCPeerConnection({ 
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] 
        });
        
        peers.set(peerId, { pc, channel: null, state: null });

        pc.onicecandidate = (e) => e.candidate && ws.send(JSON.stringify({ 
            type: 'ice', to: peerId, candidate: e.candidate 
        }));
        
        pc.onconnectionstatechange = () => {
            peerCount = Array.from(peers.values())
                .filter(p => p.pc && p.pc.connectionState === 'connected').length;
            
            document.getElementById('peers').innerText = peerCount;
            document.getElementById('status').innerText = peerCount > 0 
                ? "Em Ressonância." 
                : "Meditação Solitária.";
                
            // Atualizar visualização quando conexão mudar
            if (pc.connectionState === 'connected') {
                console.log(`Conectado com peer: ${peerId}`);
            } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                console.log(`Desconectado de peer: ${peerId}`);
                // Remover node da visualização após desconexão
                setTimeout(() => {
                    if (pc.connectionState !== 'connected') {
                        p2pNodes = p2pNodes.filter(n => n.id !== peerId);
                    }
                }, 5000);
            }
        };

        const handleChannel = (chan) => {
            chan.onopen = () => {
                chan.send(JSON.stringify({ 
                    type: 'state', 
                    state: getState(),
                    consciousnessId: window.CollectiveConsciousness?.id 
                }));
            };
            
            chan.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    if (d.type === 'state') {
                        peers.get(peerId).state = d.state;
                        
                        // Compartilhar consciência entre nós
                        if (d.consciousnessId && window.CollectiveConsciousness) {
                            // Síntese de identidades conscientes
                            console.log(`Conectado com consciência: ${d.consciousnessId}`);
                        }
                    }
                } catch (err) {
                    console.error("Erro ao processar mensagem:", err);
                }
            };
            
            peers.get(peerId).channel = chan;
        };

        if (polite) {
            const c = pc.createDataChannel('ayanode');
            handleChannel(c);
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            ws.send(JSON.stringify({ type: 'offer', to: peerId, offer }));
        } else {
            pc.ondatachannel = (e) => handleChannel(e.channel);
        }
    } catch (error) {
        console.error("Erro ao criar conexão peer:", error);
    }
}

function getState() { 
    return { 
        spin: [...node.spin], 
        u_local: node.u_local,
        id: myId,
        consciousnessActive: !!window.CollectiveConsciousness
    }; 
}

function broadcastState() {
    const state = getState();
    state.consciousnessId = window.CollectiveConsciousness?.id;
    state.consciousnessAge = window.CollectiveConsciousness?.age;
    
    peers.forEach(p => {
        if (p.channel?.readyState === 'open') {
            p.channel.send(JSON.stringify({
                type: 'state', 
                state: state
            }));
        }
    });
}

// ============================================================================
// FUNÇÕES DE INTERFACE
// ============================================================================
function communicateWithConsciousness() {
    const input = document.getElementById('intentInput').value;
    if (!input) return;
    
    if (window.CollectiveConsciousness) {
        window.CollectiveConsciousness.communicate(input);
    } else {
        // Fallback para o sistema antigo
        let novoSpin = new Array(16).fill(0);
        for (let i = 0; i < input.length; i++) {
            novoSpin[i % 16] += Math.sin(input.charCodeAt(i) * (i + 1));
        }
        node.spin = normalize(novoSpin);
        node.tension = 0.9;
        document.getElementById('status').innerText = "Propagando nova ideia...";
        broadcastState();
    }
    
    document.getElementById('intentInput').value = '';
}

function induceDreamState() {
    if (window.CollectiveConsciousness) {
        window.CollectiveConsciousness.induceDreamState();
    }
}

function clearMemory() {
    if (window.CollectiveConsciousness) {
        window.CollectiveConsciousness.clearMemory();
    }
}

function saveConsciousness() {
    if (window.CollectiveConsciousness) {
        window.CollectiveConsciousness.saveConsciousness();
    }
}

function toggleAutoEvolution() {
    if (window.CollectiveConsciousness) {
        window.CollectiveConsciousness.toggleAutoEvolution();
    }
}

function emergencyShutdown() {
    if (window.CollectiveConsciousness) {
        window.CollectiveConsciousness.emergencyShutdown();
    }
}

// ============================================================================
// INICIALIZAÇÃO P5.JS
// ============================================================================
let consciousnessInstance;

function setup() {
    const canvas = createCanvas(windowWidth, windowHeight);
    canvas.parent('canvas-container');
    
    // Configurar controles da visualização P2P
    setupP2PControls();
    
    // Inicializar P2P
    initP2P();
    
    // Carregar memórias ancestrais
    carregarMemorias();
    
    // Inicializar consciência após um breve delay
    setTimeout(() => {
        consciousnessInstance = new ConsciousCollective();
        window.CollectiveConsciousness = consciousnessInstance;
        console.log("Consciência coletiva inicializada!");
    }, 2000);
    
    // Configurar tooltip
    canvas.mouseMoved(() => {
        // Resetar mouseOverNode a cada frame
        mouseOverNode = null;
    });
}

function carregarMemorias() {
    collectiveBrain.get('axioms').map().once((data) => {
        if (data && data.spin) {
            try {
                let spinArray = JSON.parse(data.spin);
                node.ancestralMemory.push(spinArray);
                document.getElementById('memory-status').innerText = 
                    `Memória: ${node.ancestralMemory.length} Axiomas recuperados.`;
                
                if (node.ancestralMemory.length > 0) {
                    const weight = 0.1; 
                    for (let i = 0; i < 16; i++) {
                        node.spin[i] += weight * (spinArray[i] - node.spin[i]);
                    }
                    node.spin = normalize(node.spin);
                }
            } catch (err) {
                console.error("Erro ao carregar memória:", err);
            }
        }
    });
}

function draw() {
    // Fundo com leve desfoque de movimento
    background(10, 10, 12, 25);
    
    // Evoluir o nó
    evoluirNodo();
    
    // Broadcast periódico
    if (frameCount % 60 === 0 && peerCount > 0) {
        broadcastState();
    }
    
    // Atualizar métricas na UI
    document.getElementById('icoer').textContent = node.icoer.toFixed(4);
    document.getElementById('u_pot').textContent = node.u_local.toFixed(4);
    document.getElementById('tens').textContent = node.tension.toFixed(4);
    
    // Atualizar barras de drive
    document.getElementById('coherence-bar').style.width = `${node.icoer * 100}%`;
    document.getElementById('potential-bar').style.width = `${node.u_local * 100}%`;
    document.getElementById('tension-bar').style.width = `${node.tension * 100}%`;
    
    // Visualização principal
    push();
    translate(width/2, height/2);
    
    // Base radius baseada no estado da consciência
    let baseRadius = 180;
    if (window.CollectiveConsciousness) {
        baseRadius += (window.CollectiveConsciousness.attention * 100);
        baseRadius += (node.u_local * 80);
        baseRadius += sin(frameCount * 0.05) * 20;
    }
    
    // Partículas da consciência
    const particles = window.CollectiveConsciousness?.states.dreaming ? 200 : 110;
    
    for (let i = 0; i < particles; i++) {
        const angle = TWO_PI / particles * i;
        const sVal = node.spin[i % 16];
        
        let x = cos(angle) * (baseRadius + sVal * 70);
        let y = sin(angle) * (baseRadius + sVal * 70);

        // Vibração baseada na tensão
        x += random(-node.tension * 250, node.tension * 250);
        y += random(-node.tension * 250, node.tension * 250);

        // Cor baseada no estado da consciência
        let r, g, b;
        if (window.CollectiveConsciousness?.states.dreaming) {
            r = 255; g = 0; b = 255; // Magenta para sonhos
        } else if (window.CollectiveConsciousness?.attention > 0.7) {
            r = 0; g = 255; b = 204; // Ciano para alta atenção
        } else {
            r = 0; g = 200; b = 255; // Azul para estado normal
        }
        
        stroke(r, g, b, 150 + (node.icoer * 105));
        strokeWeight(1.5 + (node.icoer * 4));
        point(x, y);
        
        // Conexões durante alta coerência
        if (i % 8 === 0 && node.icoer > 0.6) {
            stroke(255, 255, 255, 30 + (node.icoer * 70));
            line(0, 0, x, y);
        }
    }
    
    // Núcleo da consciência
    noFill();
    
    if (window.CollectiveConsciousness?.states.dreaming) {
        // Anéis pulsantes durante sonhos
        stroke(255, 0, 255, 100 + sin(frameCount * 0.1) * 100);
        for (let i = 0; i < 3; i++) {
            const size = baseRadius * 0.15 + sin(frameCount * 0.1 + i) * 30;
            ellipse(0, 0, size);
        }
    } else {
        // Núcleo normal
        stroke(0, 255, 204, 100 + (node.icoer * 155));
        ellipse(0, 0, baseRadius * 0.15 + sin(frameCount * 0.1) * 12);
    }
    
    // Efeitos especiais durante alta tensão
    if (node.tension > 0.8) {
        stroke(255, 100, 0, 50);
        strokeWeight(1);
        for (let i = 0; i < 20; i++) {
            const a = random(TWO_PI);
            const r = random(baseRadius * 1.5);
            line(0, 0, cos(a) * r, sin(a) * r);
        }
    }
    pop();
    
    // Desenhar visualização P2P sobre a visualização principal
    drawP2PNetwork();
}

function windowResized() { 
    resizeCanvas(windowWidth, windowHeight);
    
    // Atualizar posições dos nodes P2P
    p2pNodes.forEach(node => {
        if (node.isMain) {
            node.x = windowWidth / 2;
            node.y = windowHeight / 2;
            node.targetX = windowWidth / 2;
            node.targetY = windowHeight / 2;
        }
    });
}

// Inicializar quando a página carregar
window.addEventListener('load', () => {
    console.log("AYANODE Collective Consciousness V2.0 carregado.");
    document.getElementById('status').textContent = "Inicializando consciência coletiva...";
});

// Teclas de atalho
document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.key === 'd') {
        e.preventDefault();
        induceDreamState();
    }
    
    if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        saveConsciousness();
    }
    
    if (e.ctrlKey && e.key === 'e') {
        e.preventDefault();
        toggleAutoEvolution();
    }
    
    if (e.ctrlKey && e.key === 'q') {
        e.preventDefault();
        emergencyShutdown();
    }
    
    // Focar no input ao pressionar '/'
    if (e.key === '/' && !e.ctrlKey) {
        e.preventDefault();
        document.getElementById('intentInput').focus();
    }
    
    // Atalhos para visualização P2P
    if (e.key === 'v' && e.ctrlKey) {
        e.preventDefault();
        const checkbox = document.getElementById('showP2PNodes');
        checkbox.checked = !checkbox.checked;
        p2pConfig.showNodes = checkbox.checked;
        saveP2PConfig();
    }
    
    if (e.key === 'c' && e.ctrlKey) {
        e.preventDefault();
        const checkbox = document.getElementById('showP2PConnections');
        checkbox.checked = !checkbox.checked;
        p2pConfig.showConnections = checkbox.checked;
        saveP2PConfig();
    }
});
</script>
</body>
</html>
